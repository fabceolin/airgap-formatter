# Test Design: Story 5.2 - Refactor Async Operations to Use AsyncSerialiser

**Date:** 2026-01-26
**Designer:** Quinn (Test Architect)
**Story:** 5.2.refactor-async-operations
**Risk Level:** Elevated (61/100 from risk profile)

## Test Strategy Overview

- **Total test scenarios:** 47
- **Unit tests:** 14 (30%)
- **Integration tests:** 21 (45%)
- **E2E tests:** 12 (25%)
- **Priority distribution:** P0: 18, P1: 19, P2: 8, P3: 2

### Strategy Rationale

This story fundamentally changes the async execution pattern from synchronous returns to signal-based results. The test strategy prioritizes:

1. **Integration-heavy approach** - Signal emission and QML connection patterns require component interaction testing
2. **P0 emphasis on critical path signals** - Each of the 7 async operations must emit signals correctly
3. **Edge case coverage** - Rapid clicks and queue behavior are explicitly required by AC 17-19
4. **Risk mitigation focus** - TECH-001 (signal timing) addressed by dedicated timing verification tests

---

## Test Scenarios by Acceptance Criteria

### AC 1: formatJson() uses AsyncSerialiser

| ID | Level | Priority | Test | Justification | Mitigates |
|----|-------|----------|------|---------------|-----------|
| 5.2-UNIT-001 | Unit | P0 | formatJson enqueues task to AsyncSerialiser | Core migration requirement; verify queue integration | TECH-001 |
| 5.2-UNIT-002 | Unit | P1 | formatJson captures input and indentType in closure | Data integrity in async context | TECH-004 |
| 5.2-INT-001 | Integration | P0 | formatJson emits formatCompleted signal after queue execution | Signal timing critical path | TECH-001 |
| 5.2-INT-002 | Integration | P0 | formatJson signal contains success=true and result on valid JSON | Result structure validation | TECH-001 |
| 5.2-INT-003 | Integration | P0 | formatJson signal contains success=false and error on invalid JSON | Error path validation | TECH-004 |

### AC 2: minifyJson() uses AsyncSerialiser

| ID | Level | Priority | Test | Justification | Mitigates |
|----|-------|----------|------|---------------|-----------|
| 5.2-UNIT-003 | Unit | P0 | minifyJson enqueues task to AsyncSerialiser | Core migration requirement | TECH-001 |
| 5.2-INT-004 | Integration | P0 | minifyJson emits minifyCompleted signal with result | Signal emission verification | TECH-001 |
| 5.2-INT-005 | Integration | P1 | minifyJson handles large JSON (>1MB) without timeout | Performance boundary | - |

### AC 3: validateJson() uses AsyncSerialiser

| ID | Level | Priority | Test | Justification | Mitigates |
|----|-------|----------|------|---------------|-----------|
| 5.2-UNIT-004 | Unit | P0 | validateJson enqueues task to AsyncSerialiser | Core migration requirement | TECH-001 |
| 5.2-INT-006 | Integration | P0 | validateJson emits validateCompleted with isValid=true for valid JSON | Success path | TECH-001 |
| 5.2-INT-007 | Integration | P0 | validateJson emits validateCompleted with error details for invalid JSON | Error details include line/column | TECH-004 |

### AC 4: saveToHistory() uses AsyncSerialiser

| ID | Level | Priority | Test | Justification | Mitigates |
|----|-------|----------|------|---------------|-----------|
| 5.2-UNIT-005 | Unit | P1 | saveToHistory enqueues IndexedDB operation | Core migration | TECH-001 |
| 5.2-INT-008 | Integration | P0 | saveHistoryCompleted(true) emitted on successful save | IndexedDB async completion | TECH-001, DATA-001 |
| 5.2-INT-009 | Integration | P1 | saveHistoryCompleted(false) emitted on IndexedDB failure | Error signal path | TECH-004 |

### AC 5: loadHistory() uses AsyncSerialiser

| ID | Level | Priority | Test | Justification | Mitigates |
|----|-------|----------|------|---------------|-----------|
| 5.2-UNIT-006 | Unit | P1 | loadHistory enqueues IndexedDB read operation | Core migration | TECH-001 |
| 5.2-INT-010 | Integration | P0 | loadHistoryCompleted emits QVariantList of entries | Data structure integrity | TECH-001 |
| 5.2-INT-011 | Integration | P1 | loadHistoryCompleted emits empty list when no history | Edge case - empty state | - |

### AC 6: copyToClipboard() uses AsyncSerialiser

| ID | Level | Priority | Test | Justification | Mitigates |
|----|-------|----------|------|---------------|-----------|
| 5.2-UNIT-007 | Unit | P1 | copyToClipboard enqueues navigator.clipboard.writeText | Core migration | TECH-001 |
| 5.2-INT-012 | Integration | P0 | copyCompleted(true) emitted after successful clipboard write | Async clipboard API | TECH-001 |
| 5.2-INT-013 | Integration | P1 | copyCompleted(false) emitted when clipboard API fails (permissions) | Browser permission handling | TECH-004 |

### AC 7: readFromClipboard() uses AsyncSerialiser

| ID | Level | Priority | Test | Justification | Mitigates |
|----|-------|----------|------|---------------|-----------|
| 5.2-UNIT-008 | Unit | P1 | readFromClipboard enqueues navigator.clipboard.readText | Core migration | TECH-001 |
| 5.2-INT-014 | Integration | P0 | clipboardRead(content) emitted with clipboard text | Async clipboard read | TECH-001 |
| 5.2-INT-015 | Integration | P1 | clipboardRead emits empty string when clipboard empty | Edge case | - |

### AC 8: QML receives results via signals

| ID | Level | Priority | Test | Justification | Mitigates |
|----|-------|----------|------|---------------|-----------|
| 5.2-INT-016 | Integration | P0 | Main.qml Connections block receives formatCompleted | QML signal connection | TECH-001 |
| 5.2-INT-017 | Integration | P0 | Main.qml Connections block receives validateCompleted | QML signal connection | TECH-001 |
| 5.2-E2E-001 | E2E | P0 | Format button click results in output pane update via signal | Full signal flow | TECH-001, TECH-002 |

### AC 9: Each operation has success/error signals

| ID | Level | Priority | Test | Justification | Mitigates |
|----|-------|----------|------|---------------|-----------|
| 5.2-UNIT-009 | Unit | P1 | JsonBridge declares all 10 required signals in header | API completeness | - |
| 5.2-INT-018 | Integration | P1 | Each of 7 operations emits corresponding signal | Systematic signal verification | TECH-001 |

### AC 10: UI shows loading state while operation queued/executing

| ID | Level | Priority | Test | Justification | Mitigates |
|----|-------|----------|------|---------------|-----------|
| 5.2-UNIT-010 | Unit | P1 | isBusy property returns true when queue non-empty | Busy state logic | TECH-005 |
| 5.2-UNIT-011 | Unit | P1 | busyChanged signal emits when queue transitions empty/non-empty | State change notification | TECH-005 |
| 5.2-E2E-002 | E2E | P1 | Toolbar shows loading indicator during format operation | Visual loading state | OPS-002 |
| 5.2-E2E-003 | E2E | P2 | Buttons disabled during queue execution (optional behavior) | UX during busy | OPS-002 |

### AC 11: Error messages displayed to user on failure

| ID | Level | Priority | Test | Justification | Mitigates |
|----|-------|----------|------|---------------|-----------|
| 5.2-E2E-004 | E2E | P0 | Invalid JSON format shows error message in UI | User error feedback | TECH-004 |
| 5.2-E2E-005 | E2E | P1 | Error message includes line and column when available | Actionable error info | TECH-004 |

### AC 12: Format operation populates output pane on success

| ID | Level | Priority | Test | Justification | Mitigates |
|----|-------|----------|------|---------------|-----------|
| 5.2-E2E-006 | E2E | P0 | Valid JSON formatted and displayed in output pane | Behavior preservation | - |
| 5.2-INT-019 | Integration | P0 | formatCompleted handler sets outputPane.text | Signal handler behavior | TECH-001 |

### AC 13: Validation updates status bar with results

| ID | Level | Priority | Test | Justification | Mitigates |
|----|-------|----------|------|---------------|-----------|
| 5.2-E2E-007 | E2E | P1 | Status bar shows "Valid JSON" after successful validation | Behavior preservation | - |
| 5.2-E2E-008 | E2E | P1 | Status bar shows error message after failed validation | Error status display | - |

### AC 14: History save works automatically after format

| ID | Level | Priority | Test | Justification | Mitigates |
|----|-------|----------|------|---------------|-----------|
| 5.2-INT-020 | Integration | P0 | formatCompleted triggers saveHistoryTimer | Cascading async pattern | TECH-003, OPS-001 |
| 5.2-E2E-009 | E2E | P1 | Format operation followed by history panel shows new entry | End-to-end flow | DATA-001 |

### AC 15: History load populates input pane

| ID | Level | Priority | Test | Justification | Mitigates |
|----|-------|----------|------|---------------|-----------|
| 5.2-E2E-010 | E2E | P1 | Selecting history entry loads content into input pane | Behavior preservation | - |

### AC 16: Clipboard operations work correctly

| ID | Level | Priority | Test | Justification | Mitigates |
|----|-------|----------|------|---------------|-----------|
| 5.2-E2E-011 | E2E | P1 | Copy button copies output to clipboard | Behavior preservation | - |
| 5.2-E2E-012 | E2E | P2 | Paste operation loads clipboard into input | Behavior preservation | - |

### AC 17: Rapid button clicks queue operations without crash

| ID | Level | Priority | Test | Justification | Mitigates |
|----|-------|----------|------|---------------|-----------|
| 5.2-UNIT-012 | Unit | P0 | 10 rapid enqueue calls all added to queue | Queue accumulation | TECH-003 |
| 5.2-INT-021 | Integration | P0 | 5 rapid format clicks complete in order without crash | Critical edge case per AC | TECH-001, TECH-003 |
| 5.2-UNIT-013 | Unit | P1 | Queue maintains FIFO order under rapid insertion | Order integrity | TECH-003 |

### AC 18: Operation timeout shows user-friendly error

| ID | Level | Priority | Test | Justification | Mitigates |
|----|-------|----------|------|---------------|-----------|
| 5.2-UNIT-014 | Unit | P2 | Timeout exception caught and converted to error signal | Timeout handling | TECH-004 |
| 5.2-INT-022 | Integration | P2 | Simulated slow operation times out with friendly message | UX for timeout | - |

### AC 19: Failed operation doesn't block subsequent operations

| ID | Level | Priority | Test | Justification | Mitigates |
|----|-------|----------|------|---------------|-----------|
| 5.2-INT-023 | Integration | P0 | Failed format followed by valid format succeeds | Queue recovery | TECH-003 |
| 5.2-INT-024 | Integration | P1 | Exception in one task doesn't prevent next task execution | Isolation | TECH-003 |

---

## Risk Coverage Matrix

| Risk ID | Description | Test Coverage |
|---------|-------------|---------------|
| TECH-001 | Signal timing mismatch | 5.2-INT-001 through 5.2-INT-019, 5.2-E2E-001 |
| TECH-002 | QMetaObject::invokeMethod thread safety | 5.2-E2E-001, cross-browser E2E tests |
| TECH-003 | Queue starvation / cascading operations | 5.2-INT-020, 5.2-INT-021, 5.2-INT-023, 5.2-UNIT-012 |
| TECH-004 | Error handling in signal emission | 5.2-INT-003, 5.2-INT-007, 5.2-INT-009, 5.2-E2E-004 |
| TECH-005 | isBusy race condition | 5.2-UNIT-010, 5.2-UNIT-011 |
| OPS-001 | Timer workaround conflicts | 5.2-INT-020 |
| DATA-001 | History save not checked before format | 5.2-INT-020, 5.2-E2E-009 |
| OPS-002 | Loading state on slow devices | 5.2-E2E-002, 5.2-E2E-003 |

---

## Test Environment Requirements

### Unit Tests
- **Framework:** Qt Test (QTest)
- **Environment:** Desktop build with mocked AsyncSerialiser
- **Mocks Required:**
  - AsyncSerialiser::enqueue (verify task capture)
  - val::await() for WASM simulation
- **Execution Time Target:** <5 seconds total

### Integration Tests
- **Framework:** Qt Test with Emscripten WASM build
- **Environment:** WASM module in browser context (headless Chrome)
- **Real Components:**
  - AsyncSerialiser (real implementation from 5.1)
  - JsonBridge with signal connections
  - IndexedDB (browser storage)
- **Mocks Required:**
  - None - test real signal flow
- **Execution Time Target:** <30 seconds total

### E2E Tests
- **Framework:** Playwright or similar browser automation
- **Environment:** Full WASM application in browser
- **Browsers:** Chrome (primary), Firefox (secondary)
- **Test Data:**
  - Valid JSON samples (small, medium, large)
  - Invalid JSON samples with various error types
- **Execution Time Target:** <2 minutes total

---

## Test Data Requirements

### JSON Test Fixtures

```yaml
valid_json_samples:
  - small: '{"name": "test"}' # <100 bytes
  - medium: # ~10KB nested object
  - large: # ~1MB array for performance boundary

invalid_json_samples:
  - missing_bracket: '{"name": "test"'
  - trailing_comma: '{"name": "test",}'
  - invalid_unicode: '{"name": "\uXXXX"}'
  - deeply_nested: # >100 levels for stack test

edge_case_samples:
  - empty_object: '{}'
  - empty_array: '[]'
  - unicode_heavy: # Japanese, emoji, RTL text
  - whitespace_heavy: # Significant whitespace in strings
```

### Rapid Click Test Configuration

```yaml
rapid_click_tests:
  - clicks: 5
    interval_ms: 50  # 100ms between clicks
    expected: all_complete_in_order

  - clicks: 10
    interval_ms: 20  # 50ms between clicks (stress)
    expected: all_complete_no_crash

  - clicks: 20
    interval_ms: 10  # Extreme stress
    expected: queue_may_limit_but_no_crash
```

---

## Recommended Execution Order

1. **P0 Unit Tests (5)** - Fail fast on queue integration
   - 5.2-UNIT-001, 003, 004, 012, 014

2. **P0 Integration Tests (12)** - Signal emission verification
   - 5.2-INT-001 through 008, 012, 016, 019, 021, 023

3. **P0 E2E Tests (3)** - Critical user paths
   - 5.2-E2E-001, 004, 006

4. **P1 Tests (19)** - Core functionality
   - Remaining unit and integration tests
   - E2E behavior preservation tests

5. **P2+ Tests (10)** - Nice to have
   - Timeout handling, optional UI states

---

## Quality Checklist

- [x] Every AC has at least one test scenario
- [x] No duplicate coverage across levels (integration tests signal flow, E2E tests user experience)
- [x] Critical paths (AC 17 rapid clicks) have multiple test levels
- [x] All 9 identified risks have mitigation tests
- [x] Test IDs follow 5.2-{LEVEL}-{SEQ} convention
- [x] Scenarios are atomic and independent
- [x] Shift-left applied: 30% unit, 45% integration, 25% E2E

---

## Gate YAML Block

```yaml
test_design:
  scenarios_total: 47
  by_level:
    unit: 14
    integration: 21
    e2e: 12
  by_priority:
    p0: 18
    p1: 19
    p2: 8
    p3: 2
  coverage_gaps: []
  risk_coverage:
    tech_001: 15 tests
    tech_002: 2 tests
    tech_003: 5 tests
    tech_004: 5 tests
    tech_005: 2 tests
```

---

## Trace References

```
Test design matrix: docs/qa/assessments/5.2-test-design-20260126.md
P0 tests identified: 18
Total scenarios: 47
Risk coverage: 9/9 risks addressed
```
