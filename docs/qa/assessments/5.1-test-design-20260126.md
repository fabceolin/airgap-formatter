# Test Design: Story 5.1 - AsyncSerialiser C++ Implementation

**Date:** 2026-01-26
**Designer:** Quinn (Test Architect)
**Story:** 5.1 AsyncSerialiser C++ Implementation
**Risk Level:** CONCERNS (78/100)

## Test Strategy Overview

- **Total test scenarios:** 28
- **Unit tests:** 18 (64%)
- **Integration tests:** 8 (29%)
- **E2E tests:** 2 (7%)
- **Priority distribution:** P0: 10, P1: 12, P2: 6

### Test Pyramid Rationale

This component is a low-level concurrency primitive that other stories (5.2, 5.3) will depend on. Testing emphasizes:
1. **Unit tests** for the core serialization invariant and queue logic
2. **Integration tests** for Qt/WASM platform behavior (high-risk areas TECH-001, TECH-003)
3. **E2E tests** only for critical browser runtime validation

## Test Scenarios by Acceptance Criteria

### AC1: Singleton Accessibility

> `AsyncSerialiser` singleton class exists and is accessible from any C++ code

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 5.1-UNIT-001 | Unit | P0 | `instance()` returns same object on repeated calls | Singleton invariant is foundational |
| 5.1-UNIT-002 | Unit | P1 | Singleton survives module boundary access | Ensures linker doesn't create duplicates |
| 5.1-UNIT-003 | Unit | P2 | Singleton thread safety under concurrent access | Edge case for potential future multi-threading |

**Given-When-Then:**
```gherkin
Scenario: Singleton returns consistent instance
  Given the AsyncSerialiser has not been accessed
  When instance() is called from multiple locations
  Then all calls return the same memory address
```

---

### AC2: Enqueue Method

> `enqueue(task)` method accepts a lambda that returns `QFuture<QVariant>`

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 5.1-UNIT-004 | Unit | P0 | `enqueue()` accepts lambda returning QFuture<QVariant> | Core API contract |
| 5.1-UNIT-005 | Unit | P1 | `enqueue()` accepts std::function wrapper | API flexibility |
| 5.1-UNIT-006 | Unit | P1 | `enqueue()` with capturing lambda works correctly | Memory safety for captured variables |

**Given-When-Then:**
```gherkin
Scenario: Enqueue accepts valid task
  Given an AsyncSerialiser instance
  When enqueue() is called with a lambda returning QFuture<QVariant>
  Then the task is added to the internal queue
  And queueLengthChanged signal is emitted
```

---

### AC3: Single Task Execution (m_isBusy Guard)

> Only one task executes at a time (m_isBusy guard)

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 5.1-UNIT-007 | Unit | P0 | Two enqueued tasks do not run concurrently | **CRITICAL** - Core serialization invariant |
| 5.1-UNIT-008 | Unit | P0 | m_isBusy is true during task execution | Guards against re-entry |
| 5.1-UNIT-009 | Unit | P1 | Rapid enqueue calls don't bypass guard | Stress test for race conditions |
| 5.1-INT-001 | Integration | P0 | Serialization holds under WASM event loop | **Mitigates TECH-001** |

**Given-When-Then:**
```gherkin
Scenario: Serialization invariant maintained
  Given a slow task (100ms) is executing
  When a second task is enqueued
  Then the second task waits until the first completes
  And m_isBusy is never false while a task runs
```

---

### AC4: FIFO Order

> Queued tasks execute in FIFO order when previous task completes

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 5.1-UNIT-010 | Unit | P0 | Three tasks execute in enqueue order | FIFO is required behavior |
| 5.1-UNIT-011 | Unit | P1 | Order maintained after error in middle task | Error handling doesn't corrupt order |

**Given-When-Then:**
```gherkin
Scenario: FIFO ordering preserved
  Given tasks A, B, C are enqueued in that order
  When all tasks complete
  Then taskCompleted signals fire in order A, B, C
```

---

### AC5: QFutureWatcher Completion Detection

> `QFutureWatcher` is used to detect task completion

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 5.1-UNIT-012 | Unit | P1 | QFutureWatcher::finished triggers processNext | Internal mechanism |
| 5.1-INT-002 | Integration | P0 | QFutureWatcher::finished fires in WASM | **Mitigates TECH-001** |

**Given-When-Then:**
```gherkin
Scenario: QFutureWatcher detects completion
  Given a task is executing
  When the task's QFuture resolves
  Then QFutureWatcher::finished signal fires
  And processNext() is called to advance queue
```

---

### AC6: Watchdog Timer

> Watchdog timer aborts stuck tasks after 30 seconds

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 5.1-UNIT-013 | Unit | P0 | Watchdog fires after 30s timeout | Core safety feature |
| 5.1-UNIT-014 | Unit | P1 | Watchdog is stopped when task completes normally | Prevent false triggers |
| 5.1-INT-003 | Integration | P0 | QTimer watchdog fires correctly in WASM | **Mitigates TECH-003** |
| 5.1-INT-004 | Integration | P1 | Watchdog works with browser tab backgrounding | WASM-specific edge case |

**Given-When-Then:**
```gherkin
Scenario: Watchdog aborts stuck task
  Given a task is executing and hangs indefinitely
  When 30 seconds elapse
  Then taskTimedOut signal is emitted
  And taskCompleted signal fires with success=false
  And m_isBusy is reset to false
  And next queued task begins
```

---

### AC7: Queue Clearing

> Queue can be cleared on critical errors without memory leaks

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 5.1-UNIT-015 | Unit | P0 | clearQueue() empties queue and resets state | Emergency recovery mechanism |
| 5.1-UNIT-016 | Unit | P1 | clearQueue() during task execution cleans up watcher | **Mitigates DATA-001** |
| 5.1-INT-005 | Integration | P1 | No memory leak after clearQueue (valgrind/ASAN) | Memory safety verification |

**Given-When-Then:**
```gherkin
Scenario: Emergency queue clear
  Given 5 tasks are queued and 1 is executing
  When clearQueue() is called
  Then queue is empty
  And m_isBusy is false
  And QFutureWatcher is cleaned up
  And no memory leaks occur
```

---

### AC8: Error Isolation

> Error in one task does not block subsequent tasks

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 5.1-UNIT-017 | Unit | P0 | Exception in task allows next task to run | Queue resilience |
| 5.1-UNIT-018 | Unit | P1 | QFuture cancellation allows next task | Handles user-initiated cancellation |

**Given-When-Then:**
```gherkin
Scenario: Error does not block queue
  Given tasks A (will fail), B (will succeed) are queued
  When task A throws an exception
  Then taskCompleted(A, false) is emitted
  And task B executes successfully
  And taskCompleted(B, true) is emitted
```

---

### AC9 & AC10: Task Lifecycle Signals

> Signal emitted when task starts/completes

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 5.1-INT-006 | Integration | P1 | taskStarted signal carries correct taskName | QML observability |
| 5.1-INT-007 | Integration | P1 | taskCompleted signal carries correct taskName and success | QML observability |

**Given-When-Then:**
```gherkin
Scenario: Lifecycle signals fire correctly
  Given an observer is connected to taskStarted and taskCompleted
  When a task named "formatJson" is enqueued and completes
  Then taskStarted("formatJson") is emitted first
  Then taskCompleted("formatJson", true) is emitted after
```

---

### AC11: queueLength Property

> Property exposed for queue length

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 5.1-UNIT-019 | Unit | P1 | queueLength returns correct count | QML binding support |
| 5.1-INT-008 | Integration | P2 | queueLengthChanged signal works with QML binding | UI integration |

**Given-When-Then:**
```gherkin
Scenario: Queue length property updates
  Given queueLength is 0
  When 3 tasks are enqueued
  Then queueLength returns 3
  And queueLengthChanged signal fires 3 times
```

---

### AC12-14: Unit Test Quality

> Unit tests verify single-task-at-a-time, FIFO ordering, watchdog timeout

These are meta-criteria covered by the scenarios above. Verification:

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 5.1-E2E-001 | E2E | P0 | Full test suite passes in WASM browser runtime | Critical path verification |
| 5.1-E2E-002 | E2E | P1 | Full test suite passes on native Qt build | Cross-platform verification |

---

### AC15: Compiler Warnings

> No compiler warnings with `-Wall -Wextra`

| ID | Level | Priority | Test | Justification |
|----|-------|----------|------|---------------|
| 5.1-UNIT-020 | Unit | P2 | Compilation produces zero warnings with -Wall -Wextra | Code quality gate |

---

## Risk Coverage Matrix

| Risk ID | Description | Test Coverage |
|---------|-------------|---------------|
| TECH-001 | QFuture/QPromise differs in WASM | 5.1-INT-001, 5.1-INT-002 |
| TECH-003 | QTimer inconsistent in WASM | 5.1-INT-003, 5.1-INT-004 |
| OPS-001 | Watchdog timeout too short | 5.1-UNIT-013, 5.1-UNIT-014 |
| TECH-002 | QMetaObject::invokeMethod fails | Covered by 5.1-INT-001 |
| TECH-005 | Reentrancy in processNext() | 5.1-UNIT-009 |
| DATA-001 | Memory leak from orphaned watcher | 5.1-UNIT-016, 5.1-INT-005 |
| TECH-004 | Singleton initialization order | 5.1-UNIT-001, 5.1-UNIT-002 |

## Test Data Requirements

### Test Fixtures

```cpp
// Fast task (immediate completion)
auto fastTask = []() {
    QPromise<QVariant> p;
    p.start();
    p.addResult(QVariant("fast"));
    p.finish();
    return p.future();
};

// Slow task (100ms delay)
auto slowTask = []() {
    QPromise<QVariant> p;
    auto future = p.future();
    QTimer::singleShot(100, [p = std::move(p)]() mutable {
        p.addResult(QVariant("slow"));
        p.finish();
    });
    return future;
};

// Failing task (throws exception)
auto failingTask = []() {
    QPromise<QVariant> p;
    p.start();
    p.setException(std::runtime_error("test failure"));
    p.finish();
    return p.future();
};

// Hanging task (never completes - for watchdog testing)
auto hangingTask = []() {
    QPromise<QVariant> p;
    p.start();
    // Never calls finish() - simulates stuck task
    return p.future();
};
```

### Environment Requirements

| Environment | Purpose | Required |
|-------------|---------|----------|
| Native Qt 6.10 | Fast unit test execution | Yes |
| Emscripten 4.0.7 + Chrome | WASM integration tests | Yes |
| valgrind/ASAN | Memory leak detection | Recommended |
| Firefox WASM | Cross-browser verification | Optional |

### Test Execution Order

1. **Phase 1: Fast Feedback (Native)**
   - P0 Unit tests: 5.1-UNIT-001, 007, 008, 010, 013, 015, 017
   - Expected duration: <5 seconds

2. **Phase 2: Integration (Native)**
   - P0 Integration tests on native build first
   - Expected duration: <30 seconds

3. **Phase 3: WASM Verification**
   - P0 Integration tests in browser: 5.1-INT-001, 002, 003
   - Expected duration: <2 minutes

4. **Phase 4: Full Suite**
   - All P1, P2 tests
   - E2E browser tests
   - Expected duration: <5 minutes

## Gate YAML Block

```yaml
test_design:
  scenarios_total: 28
  by_level:
    unit: 18
    integration: 8
    e2e: 2
  by_priority:
    p0: 10
    p1: 12
    p2: 6
  coverage_gaps: []
  risk_mitigation:
    TECH-001: [5.1-INT-001, 5.1-INT-002]
    TECH-003: [5.1-INT-003, 5.1-INT-004]
    DATA-001: [5.1-UNIT-016, 5.1-INT-005]
```

## Recommendations

1. **Critical**: Tests 5.1-INT-001 through 5.1-INT-003 must run in actual WASM environment, not just native Qt
2. **High Priority**: Consider using `emscripten_set_timeout` as QTimer fallback if TECH-003 manifests
3. **Medium Priority**: Add performance assertions to measure queue overhead (<10ms target from NFR assessment)
4. **Low Priority**: Consider property-based testing for FIFO invariant using QuickCheck-style framework
