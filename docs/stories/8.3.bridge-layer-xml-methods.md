# Story 8.3: Bridge Layer XML Methods

## Status: Approved

## Story

**As a** QML frontend developer,
**I want** XML formatting methods exposed through JsonBridge,
**so that** the UI can format and highlight XML using the same patterns as JSON.

## Acceptance Criteria

1. `formatXml(input, indentType)` method added to JsonBridge
2. `minifyXml(input)` method added to JsonBridge
3. `highlightXml(input)` synchronous method added to JsonBridge
4. Async methods emit completion signals with result/error
5. All XML methods integrate with AsyncSerialiser pattern
6. Existing JSON methods continue to work unchanged
7. Bridge compiles for both native and WASM targets

## Tasks / Subtasks

- [ ] Task 1: Add XML method declarations to jsonbridge.h (AC: 1, 2, 3, 4)
  - [ ] Add `Q_INVOKABLE void formatXml(const QString &input, const QString &indentType)`
  - [ ] Add `Q_INVOKABLE void minifyXml(const QString &input)`
  - [ ] Add `Q_INVOKABLE QString highlightXml(const QString &input)`
  - [ ] Add signal `void formatXmlCompleted(const QVariantMap &result)`
  - [ ] Add signal `void minifyXmlCompleted(const QVariantMap &result)`

- [ ] Task 2: Implement XML methods in jsonbridge.cpp (AC: 1, 2, 3, 5)
  - [ ] Implement `formatXml()` following `formatJson()` pattern
  - [ ] Implement `minifyXml()` following `minifyJson()` pattern
  - [ ] Implement `highlightXml()` following `highlightJson()` pattern
  - [ ] Use AsyncSerialiser::enqueue() for async methods
  - [ ] Call WASM exports: `formatXml`, `minifyXml`, `highlightXml`

- [ ] Task 3: Connect XML signals (AC: 4)
  - [ ] Connect formatXml completion to `formatXmlCompleted` signal
  - [ ] Connect minifyXml completion to `minifyXmlCompleted` signal
  - [ ] Ensure error cases emit with `success: false` and error message

- [ ] Task 4: Test native build (AC: 7)
  - [ ] Verify `qmake && make` succeeds
  - [ ] Test XML methods work in native Qt build

- [ ] Task 5: Test WASM build (AC: 6, 7)
  - [ ] Verify Qt WASM build succeeds
  - [ ] Test XML methods call through to Rust WASM correctly
  - [ ] Verify JSON methods still work (regression test)

## Dev Notes

### Relevant Source Tree

```
qt/
├── jsonbridge.h        # TARGET - add XML method declarations
├── jsonbridge.cpp      # TARGET - implement XML methods
├── asyncserialiser.h   # REFERENCE - async pattern
└── CMakeLists.txt      # No changes needed

public/
└── bridge.js           # WASM bridge - exports already added in spike
```

### Existing JSON Pattern (jsonbridge.h:29-34)

```cpp
// Async operations (fire-and-forget, results via signals)
Q_INVOKABLE void formatJson(const QString &input, const QString &indentType);
Q_INVOKABLE void minifyJson(const QString &input);
Q_INVOKABLE void validateJson(const QString &input);

// Synchronous operations
Q_INVOKABLE QString highlightJson(const QString &input);
```

### XML Methods to Add

```cpp
// Async XML operations
Q_INVOKABLE void formatXml(const QString &input, const QString &indentType);
Q_INVOKABLE void minifyXml(const QString &input);

// Synchronous XML operations
Q_INVOKABLE QString highlightXml(const QString &input);

signals:
    void formatXmlCompleted(const QVariantMap &result);
    void minifyXmlCompleted(const QVariantMap &result);
```

### AsyncSerialiser Integration Pattern

From existing `formatJson()` implementation:
```cpp
void JsonBridge::formatJson(const QString &input, const QString &indentType)
{
    AsyncSerialiser::instance().enqueue("formatJson", [this, input, indentType]() {
        QPromise<QVariant> promise;
        auto future = promise.future();
        promise.start();

        #ifdef __EMSCRIPTEN__
        val bridge = val::global("JsonBridge");
        val result = bridge.call<val>("format", input.toStdString(), indentType.toStdString());
        // ... handle result
        #endif

        return future;
    });
}
```

### WASM Exports (already in lib.rs from spike)

```rust
#[wasm_bindgen(js_name = "formatXml")]
pub fn js_format_xml(input: &str, indent: &str) -> Result<String, JsValue>

#[wasm_bindgen(js_name = "minifyXml")]
pub fn js_minify_xml(input: &str) -> Result<String, JsValue>

#[wasm_bindgen(js_name = "highlightXml")]
pub fn js_highlight_xml(input: &str) -> String
```

### Signal Result Format

Match existing JSON signal format:
```cpp
QVariantMap result;
result["success"] = true;
result["result"] = formattedXml;
// OR on error:
result["success"] = false;
result["error"] = errorMessage;
emit formatXmlCompleted(result);
```

## Testing

### Test Location
- File: `qt/tests/tst_jsonbridge_xml.cpp` (new file)
- Or extend: `qt/tests/tst_jsonbridge_async.cpp`

### Test Cases

| Test | Input | Expected |
|------|-------|----------|
| formatXml success | `<root/>` | Signal with formatted XML |
| formatXml error | `<root` | Signal with error message |
| minifyXml success | `<root>\n</root>` | Signal with `<root></root>` |
| highlightXml | `<root/>` | HTML with color spans |
| JSON still works | `{"a":1}` | formatJson still works |

### Building & Testing
```bash
# Native build
cd qt && mkdir -p build && cd build
cmake .. && make

# Run tests
./tests/tst_jsonbridge_xml

# WASM build
emcmake cmake .. && make
```

## Definition of Done

- [ ] All acceptance criteria met
- [ ] All tasks completed
- [ ] Native build succeeds
- [ ] WASM build succeeds
- [ ] JSON methods regression tested
- [ ] XML methods tested

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-26 | 1.0 | Story created from Epic 8.0 | Sarah (PO) |
