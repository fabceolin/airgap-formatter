# Story 8.6: XML Tree Model

## Status: Approved

## Story

**As a** user viewing XML in Tree view,
**I want** a collapsible tree representation of my XML structure,
**so that** I can explore and navigate XML the same way I do with JSON.

## Acceptance Criteria

1. `QXmlTreeModel` class created following `QJsonTreeModel` pattern
2. XML elements displayed as expandable nodes
3. XML attributes displayed as child nodes with `@` prefix
4. Text content displayed as leaf nodes
5. Namespaces and prefixes preserved in display
6. Copy node functionality works (serializes selected node as XML)
7. Tree view switches between JSON and XML model based on format
8. Performance acceptable for documents up to 10,000 nodes

## Tasks / Subtasks

- [ ] Task 1: Create QXmlTreeItem class (AC: 2, 3, 4, 5)
  - [ ] Create `qt/qxmltreeitem.h` and `qt/qxmltreeitem.cpp`
  - [ ] Define item types: Element, Attribute, Text, Comment, CData
  - [ ] Store: tag name, value, namespace prefix, children
  - [ ] Implement `appendChild()`, `child()`, `childCount()`, `row()`, `parent()`

- [ ] Task 2: Create QXmlTreeModel class (AC: 1, 2, 6)
  - [ ] Create `qt/qxmltreemodel.h` and `qt/qxmltreemodel.cpp`
  - [ ] Inherit from `QAbstractItemModel`
  - [ ] Implement required interface: `index()`, `parent()`, `rowCount()`, `columnCount()`, `data()`
  - [ ] Define roles: KeyRole, ValueRole, ValueTypeRole, XmlPathRole, ChildCountRole, IsExpandableRole

- [ ] Task 3: Implement XML parsing (AC: 2, 3, 4, 5)
  - [ ] Add `Q_INVOKABLE bool loadXml(const QString& xmlString)`
  - [ ] Use QXmlStreamReader for parsing
  - [ ] Create QXmlTreeItem for each element
  - [ ] Create child items for attributes with `@` prefix
  - [ ] Create child items for text content
  - [ ] Preserve namespace prefixes (e.g., `ns:element`)

- [ ] Task 4: Implement serialization (AC: 6)
  - [ ] Add `Q_INVOKABLE QString serializeNode(const QModelIndex& index) const`
  - [ ] Serialize element and children as XML string
  - [ ] Include attributes in serialization
  - [ ] Handle text content and CDATA

- [ ] Task 5: Add to JsonBridge (AC: 7)
  - [ ] Add `QXmlTreeModel* m_xmlTreeModel` member
  - [ ] Add `Q_PROPERTY(QXmlTreeModel* xmlTreeModel READ xmlTreeModel CONSTANT)`
  - [ ] Add `Q_INVOKABLE bool loadXmlTreeModel(const QString &xml)`
  - [ ] Initialize model in constructor

- [ ] Task 6: Update CMakeLists.txt
  - [ ] Add `qxmltreeitem.cpp` to sources
  - [ ] Add `qxmltreemodel.cpp` to sources
  - [ ] Add headers to include list

- [ ] Task 7: Update TreeView.qml for format awareness (AC: 7)
  - [ ] Accept `model` property that can be either JSON or XML model
  - [ ] Update Main.qml to pass correct model based on format

- [ ] Task 8: Performance testing (AC: 8)
  - [ ] Test with 1,000 node document
  - [ ] Test with 10,000 node document
  - [ ] Verify UI remains responsive

## Dev Notes

### Relevant Source Tree

```
qt/
├── qjsontreemodel.h    # REFERENCE - copy pattern
├── qjsontreemodel.cpp  # REFERENCE - copy pattern
├── qjsontreeitem.h     # REFERENCE - copy pattern
├── qjsontreeitem.cpp   # REFERENCE - copy pattern
├── qxmltreemodel.h     # NEW - create
├── qxmltreemodel.cpp   # NEW - create
├── qxmltreeitem.h      # NEW - create
├── qxmltreeitem.cpp    # NEW - create
├── jsonbridge.h        # UPDATE - add xmlTreeModel property
├── jsonbridge.cpp      # UPDATE - add xmlTreeModel methods
├── CMakeLists.txt      # UPDATE - add new files
└── qml/
    ├── TreeView.qml    # UPDATE - format-aware model binding
    └── Main.qml        # UPDATE - pass correct model
```

### QXmlTreeItem Design

```cpp
class QXmlTreeItem
{
public:
    enum class ItemType {
        Root,
        Element,
        Attribute,
        Text,
        Comment,
        CData
    };

    explicit QXmlTreeItem(ItemType type,
                          const QString& key,
                          const QString& value,
                          QXmlTreeItem* parent = nullptr);
    ~QXmlTreeItem();

    void appendChild(QXmlTreeItem* child);
    QXmlTreeItem* child(int row) const;
    int childCount() const;
    int row() const;
    QXmlTreeItem* parent() const;

    ItemType type() const { return m_type; }
    QString key() const { return m_key; }      // Tag name or "@attrName"
    QString value() const { return m_value; }  // Text content or attr value
    QString namespacePrefix() const { return m_nsPrefix; }

private:
    ItemType m_type;
    QString m_key;
    QString m_value;
    QString m_nsPrefix;
    QList<QXmlTreeItem*> m_children;
    QXmlTreeItem* m_parent;
};
```

### QXmlTreeModel Roles

```cpp
enum Roles {
    KeyRole = Qt::UserRole + 1,      // Tag name or @attribute
    ValueRole,                        // Text content or attribute value
    ValueTypeRole,                    // "element", "attribute", "text", "comment", "cdata"
    XmlPathRole,                      // XPath-like path: /root/child[0]
    ChildCountRole,                   // Number of children
    IsExpandableRole,                 // Has children
    IsLastChildRole,                  // For tree line drawing
    NamespacePrefixRole               // "ns" for ns:element
};
```

### XML Tree Display Format

```
▼ root
  ├─ @version = "1.0"           (attribute)
  ├─ @xmlns:ns = "http://..."   (namespace attribute)
  ▼ ns:child
    ├─ @id = "1"                (attribute)
    └─ "Hello World"            (text content)
  ▼ items
    ├─ item
    │  └─ "Item 1"
    └─ item
       └─ "Item 2"
```

### XML Parsing with QXmlStreamReader

```cpp
bool QXmlTreeModel::loadXml(const QString& xmlString)
{
    beginResetModel();
    delete m_rootItem;
    m_rootItem = new QXmlTreeItem(QXmlTreeItem::ItemType::Root, "", "");

    QXmlStreamReader reader(xmlString);
    QStack<QXmlTreeItem*> stack;
    stack.push(m_rootItem);

    while (!reader.atEnd()) {
        switch (reader.readNext()) {
        case QXmlStreamReader::StartElement: {
            auto* item = new QXmlTreeItem(
                QXmlTreeItem::ItemType::Element,
                reader.name().toString(),
                "",
                stack.top()
            );
            item->setNamespacePrefix(reader.prefix().toString());
            stack.top()->appendChild(item);

            // Add attributes as children
            for (const auto& attr : reader.attributes()) {
                auto* attrItem = new QXmlTreeItem(
                    QXmlTreeItem::ItemType::Attribute,
                    "@" + attr.name().toString(),
                    attr.value().toString(),
                    item
                );
                item->appendChild(attrItem);
            }

            stack.push(item);
            break;
        }
        case QXmlStreamReader::EndElement:
            stack.pop();
            break;
        case QXmlStreamReader::Characters:
            if (!reader.isWhitespace()) {
                auto* textItem = new QXmlTreeItem(
                    QXmlTreeItem::ItemType::Text,
                    "",
                    reader.text().toString(),
                    stack.top()
                );
                stack.top()->appendChild(textItem);
            }
            break;
        // ... handle Comment, CData, etc.
        }
    }

    endResetModel();
    return !reader.hasError();
}
```

### Main.qml Model Switching

```qml
TreeView {
    id: treeView
    model: window.detectedFormat === "xml"
           ? JsonBridge.xmlTreeModel
           : JsonBridge.treeModel
}
```

## Testing

### Test Location
- File: `qt/tests/tst_qxmltreemodel.cpp` (new)

### Test Cases

| Test | Input | Expected |
|------|-------|----------|
| Simple element | `<root/>` | Root with 1 child "root" |
| With attributes | `<a b="1"/>` | "a" with child "@b" = "1" |
| Nested elements | `<a><b/></a>` | "a" → "b" |
| Text content | `<a>hello</a>` | "a" → "" = "hello" |
| Namespace | `<ns:a xmlns:ns="..."/>` | "ns:a" with prefix "ns" |
| Serialize | Select "a" node | `<a>...</a>` |
| Large doc | 10,000 nodes | Loads in < 2s |

### Running Tests
```bash
cd qt/build
cmake .. && make
./tests/tst_qxmltreemodel
```

## Definition of Done

- [ ] All acceptance criteria met
- [ ] All tasks completed
- [ ] QXmlTreeItem and QXmlTreeModel implemented
- [ ] Attributes displayed with @ prefix
- [ ] Namespaces preserved
- [ ] Copy/serialize works
- [ ] Performance acceptable
- [ ] Tree view switches based on format

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-26 | 1.0 | Story created from Epic 8.0 | Sarah (PO) |
