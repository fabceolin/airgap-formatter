# Epic 5.0: Architectural Resolution of Asyncify Conflicts in Qt WebAssembly

## Status: Draft

## Epic Summary

**As a** user of the Airgap JSON Formatter,
**I want** the application to handle all async operations (IndexedDB, clipboard, formatting) without crashing,
**so that** I can reliably use features like history loading, copy/paste, and format operations together.

## Problem Statement

The Qt WebAssembly application experiences critical crashes with the error:
```
Aborted(Assertion failed: Cannot have multiple async operations in flight at once)
```

This occurs when multiple Emscripten Asyncify-instrumented operations (such as IndexedDB history loading, JSON formatting, and validation) execute concurrently. The current QML Timer-based workaround is fragile and introduces race conditions.

### Root Cause

Emscripten's Asyncify mechanism can only suspend and resume **one** C++ call stack at a time. When `val::await()` is called from C++ to wait on a JavaScript Promise, Asyncify:
1. Unwinds the C++ stack
2. Saves state to a single static buffer
3. Yields to browser event loop
4. Rewires when Promise resolves

If a second `val::await()` is triggered before the first completes, the runtime aborts because it cannot store two stack states in one buffer.

### Affected Operations

| C++ Function | JavaScript Call | Uses Asyncify |
|--------------|-----------------|---------------|
| `formatJson()` | `JsonBridge.format()` | Yes |
| `minifyJson()` | `JsonBridge.minify()` | Yes |
| `validateJson()` | `JsonBridge.validate()` | Yes |
| `saveToHistory()` | `JsonBridge.saveHistory()` | Yes (IndexedDB) |
| `loadHistory()` | `JsonBridge.loadHistory()` | Yes (IndexedDB) |
| `copyToClipboard()` | `navigator.clipboard.writeText()` | Yes |
| `readFromClipboard()` | `navigator.clipboard.readText()` | Yes |

## Epic Goals

1. **Eliminate crashes** from concurrent async operations
2. **Ensure deterministic execution** independent of client hardware
3. **Remove fragile Timer-based workarounds**
4. **Prepare for JSPI** as the future standard

## Recommended Solution: C++ Task Serialization

Implement an `AsyncSerialiser` singleton that queues all Asyncify-dependent operations and executes them sequentially, ensuring only one async operation is "in flight" at any time.

### Architecture

```
User Action
    │
    ▼
AsyncSerialiser.enqueue(task)
    │
    ▼
┌─────────────────────────┐
│  Is Queue Busy?         │
│  ├─ Yes → Buffer task   │
│  └─ No  → Execute task  │
└─────────────────────────┘
    │
    ▼
Task executes val::await()
    │
    ▼
Asyncify suspends
    │
    ▼
Browser event loop
    │
    ▼
Promise resolves
    │
    ▼
Asyncify resumes
    │
    ▼
Task completes → Signal watcher
    │
    ▼
AsyncSerialiser.m_isBusy = false
    │
    ▼
processNext() → Execute next buffered task
```

## Stories in This Epic

| Story | Title | Scope | Dependencies |
|-------|-------|-------|--------------|
| 5.1 | AsyncSerialiser C++ Implementation | Core queue infrastructure | None |
| 5.2 | Refactor Async Operations to Use Queue | Migrate all 7 async methods | 5.1 |
| 5.3 | Remove Timer Workarounds and Test | Clean up and validate | 5.2 |
| 5.4 | JSPI Feature Detection and Future-Proofing | Browser capability detection | 5.3 (optional) |

## Acceptance Criteria (Epic Level)

### Functional
1. No "Cannot have multiple async operations in flight" errors in any scenario
2. History loading while formatting completes without crash
3. Rapid user actions (paste, format, copy, load) are queued and execute sequentially
4. All async operations maintain correct execution order
5. Operations complete within acceptable timeframes (no indefinite blocking)

### Quality
6. All existing functionality continues to work
7. No regression in performance for single operations
8. Queue timeout prevents deadlocks (30-second watchdog)
9. Error handling preserves user data and shows meaningful messages

### Maintainability
10. Clear documentation of AsyncSerialiser API
11. Single entry point for all async operations
12. Logging/debugging capability for queue state

## Out of Scope

- **JSPI as primary implementation** (browser support insufficient in 2026)
- **Web Workers** for offloading (architectural shift too large)
- **Synchronous alternatives** (localStorage limits, memory-only loses persistence)

## Technical References

- [Emscripten Asyncify Documentation](https://emscripten.org/docs/porting/asyncify.html)
- [Qt for WebAssembly](https://doc.qt.io/qt-6/wasm.html)
- [Emscripten Issue #18412](https://github.com/emscripten-core/emscripten/issues/18412)
- [QPromise Class Reference](https://doc.qt.io/qt-6/qpromise.html)
- Existing conflict report: `docs/ASYNCIFY-CONFLICT-REPORT.md`

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Queue creates noticeable delay | Medium | Low | Profile and optimize; queue is O(1) |
| Deadlock if task never completes | Low | High | Watchdog timer with 30s timeout |
| Memory leak from queued tasks | Low | Medium | Clear queue on error; weak references |
| User perceives app as "slow" | Medium | Medium | Show loading indicator during queue |

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-22 | 1.0 | Epic created from architectural analysis | Sarah (PO) |
