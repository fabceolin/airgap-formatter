# Story 10.3: Bridge Layer Markdown Methods

## Status: Draft

## Story

**As a** QML developer integrating Markdown rendering,
**I want** clean bridge methods to call Markdown and Mermaid functions,
**So that** the Qt UI can easily render documents without direct WASM/JS complexity.

## Background

This story extends the existing `bridge.js` pattern to expose Markdown and Mermaid functionality to the Qt/QML layer. It follows the established async communication pattern using the AsyncSerialiser to prevent concurrent WASM suspensions.

The key method is `renderMarkdownWithMermaid()` which orchestrates:
1. Rust WASM: Markdown → HTML (via comrak)
2. JavaScript: Find Mermaid blocks in HTML
3. JavaScript: Render each Mermaid block → SVG (via mermaid.js)
4. Return final HTML with embedded SVGs

## Acceptance Criteria

1. `renderMarkdown(input)` method added to bridge.js
   - Returns `{ success: true, html: "..." }` on success
   - Returns `{ success: false, error: "..." }` on failure
2. `renderMermaid(code)` method added to bridge.js
   - Returns `{ success: true, svg: "..." }` on success
   - Returns `{ success: false, error: "..." }` on failure
3. `renderMarkdownWithMermaid(input)` combined method added
   - Renders Markdown to HTML
   - Finds and replaces Mermaid code blocks with SVG
   - Returns complete HTML document
4. All methods integrate with AsyncSerialiser pattern
5. JsonBridge C++ class updated with corresponding signals:
   - `markdownRendered(QString html)`
   - `markdownRenderError(QString error)`
6. Methods handle null/undefined input gracefully
7. Large documents (500KB) don't block UI
8. Methods work correctly with theme parameter (dark/light)

## Tasks / Subtasks

- [ ] Task 1: Add renderMarkdown to bridge.js (AC: 1, 6)
  - [ ] Implement `renderMarkdown(input)` function
  - [ ] Validate input (handle null/undefined/empty)
  - [ ] Call `wasmModule.renderMarkdown()`
  - [ ] Return JSON result object
  - [ ] Add to `window.JsonBridge` object

- [ ] Task 2: Add renderMermaid to bridge.js (AC: 2, 6)
  - [ ] Implement `renderMermaid(code, theme)` function
  - [ ] Validate input
  - [ ] Call mermaid.render with theme config
  - [ ] Return JSON result object
  - [ ] Add to `window.JsonBridge` object

- [ ] Task 3: Implement renderMarkdownWithMermaid (AC: 3, 8)
  - [ ] Implement combined method
  - [ ] Parse HTML for `<code class="language-mermaid">` blocks
  - [ ] Extract code content from each block
  - [ ] Call renderMermaid for each block
  - [ ] Replace code blocks with SVG output
  - [ ] Handle partial failures (some diagrams fail, others succeed)
  - [ ] Pass theme parameter through

- [ ] Task 4: Add C++ bridge signals (AC: 5)
  - [ ] Add `Q_SIGNAL void markdownRendered(const QString &html)` to jsonbridge.h
  - [ ] Add `Q_SIGNAL void markdownRenderError(const QString &error)` to jsonbridge.h
  - [ ] Add `Q_INVOKABLE void requestRenderMarkdown(const QString &input)`
  - [ ] Implement signal emission from JS callback

- [ ] Task 5: Integrate with AsyncSerialiser (AC: 4, 7)
  - [ ] Wrap renderMarkdownWithMermaid in AsyncSerialiser.enqueue()
  - [ ] Use appropriate task name for queue management
  - [ ] Handle timeout gracefully
  - [ ] Test with large documents

- [ ] Task 6: Error handling (AC: 1, 2, 3)
  - [ ] Handle WASM not initialized
  - [ ] Handle mermaid not loaded
  - [ ] Handle empty/null input
  - [ ] Handle partial render failures
  - [ ] Provide meaningful error messages

- [ ] Task 7: Write integration tests (AC: 1-8)
  - [ ] Test renderMarkdown with valid input
  - [ ] Test renderMarkdown with invalid/empty input
  - [ ] Test renderMermaid with valid diagram
  - [ ] Test renderMermaid with invalid diagram
  - [ ] Test renderMarkdownWithMermaid end-to-end
  - [ ] Test theme parameter handling
  - [ ] Test large document handling

## Dev Notes

### Relevant Source Tree

```
public/
├── bridge.js           # Add Markdown/Mermaid methods
qt/
├── jsonbridge.h        # Add signals and Q_INVOKABLE methods
├── jsonbridge.cpp      # Implement JS callback handling
└── qml/
    └── Main.qml        # Connect to new signals (Story 10.5)
```

### renderMarkdown Implementation

```javascript
// In bridge.js
renderMarkdown(input) {
    const makeError = (msg) => JSON.stringify({ success: false, error: String(msg) });
    const makeSuccess = (html) => JSON.stringify({ success: true, html: String(html) });

    if (!isInitialized) {
        return makeError('WASM not initialized');
    }

    let inputStr;
    try {
        inputStr = (input === null || input === undefined) ? '' : String(input);
    } catch (e) {
        return makeError('Invalid input');
    }

    if (inputStr.trim() === '') {
        return makeSuccess('');
    }

    try {
        const html = wasmModule.renderMarkdown(inputStr);
        return makeSuccess(html);
    } catch (e) {
        console.error('[Bridge] renderMarkdown error:', e);
        return makeError(e.message || String(e));
    }
}
```

### renderMarkdownWithMermaid Implementation

```javascript
// In bridge.js
async renderMarkdownWithMermaid(input, theme = 'dark') {
    // Step 1: Render Markdown to HTML
    const mdResult = JSON.parse(this.renderMarkdown(input));
    if (!mdResult.success) {
        return JSON.stringify(mdResult);
    }

    let html = mdResult.html;

    // Step 2: Find Mermaid blocks
    const mermaidRegex = /<pre><code class="language-mermaid">([\s\S]*?)<\/code><\/pre>/g;
    const matches = [...html.matchAll(mermaidRegex)];

    if (matches.length === 0) {
        return JSON.stringify({ success: true, html: html });
    }

    // Step 3: Render each Mermaid block
    const errors = [];
    for (const match of matches) {
        const fullMatch = match[0];
        const code = this.decodeHtmlEntities(match[1]);

        try {
            const result = await window.renderMermaid(code, theme);
            if (result.success) {
                html = html.replace(fullMatch, `<div class="mermaid-diagram">${result.svg}</div>`);
            } else {
                const errorHtml = `<div class="mermaid-error"><strong>Diagram Error:</strong> ${result.error}</div>`;
                html = html.replace(fullMatch, errorHtml);
                errors.push(result.error);
            }
        } catch (e) {
            const errorHtml = `<div class="mermaid-error"><strong>Diagram Error:</strong> ${e.message}</div>`;
            html = html.replace(fullMatch, errorHtml);
            errors.push(e.message);
        }
    }

    return JSON.stringify({
        success: true,
        html: html,
        warnings: errors.length > 0 ? errors : undefined
    });
},

decodeHtmlEntities(text) {
    const textarea = document.createElement('textarea');
    textarea.innerHTML = text;
    return textarea.value;
}
```

### C++ Signal Integration

```cpp
// jsonbridge.h
class JsonBridge : public QObject
{
    Q_OBJECT

public:
    // ... existing methods ...

    Q_INVOKABLE void requestRenderMarkdown(const QString &input);
    Q_INVOKABLE void requestRenderMarkdownWithMermaid(const QString &input, bool darkTheme);

signals:
    // ... existing signals ...
    void markdownRendered(const QString &html);
    void markdownRenderError(const QString &error);
};
```

```cpp
// jsonbridge.cpp
void JsonBridge::requestRenderMarkdown(const QString &input)
{
    AsyncSerialiser::instance().enqueue("renderMarkdown", [this, input]() {
        QPromise<QVariant> promise;
        auto future = promise.future();
        promise.start();

        // Call JavaScript bridge
        emscripten::val bridge = emscripten::val::global("JsonBridge");
        emscripten::val result = bridge.call<emscripten::val>("renderMarkdown", input.toStdString());

        QString jsonResult = QString::fromStdString(result.as<std::string>());
        QJsonDocument doc = QJsonDocument::fromJson(jsonResult.toUtf8());
        QJsonObject obj = doc.object();

        if (obj["success"].toBool()) {
            emit markdownRendered(obj["html"].toString());
        } else {
            emit markdownRenderError(obj["error"].toString());
        }

        promise.addResult(QVariant(true));
        promise.finish();
        return future;
    });
}
```

### AsyncSerialiser Integration

The AsyncSerialiser (from existing codebase) ensures only one async operation runs at a time, preventing concurrent Asyncify suspensions:

```cpp
AsyncSerialiser::instance().enqueue("renderMarkdownWithMermaid", [=]() {
    // ... async work ...
});
```

## Testing

### Test Location
- JavaScript tests: Manual in browser console
- C++ tests: `qt/tests/tst_markdown_bridge.cpp` (if applicable)
- QML integration: Manual testing via UI

### Test Cases

| Method | Input | Expected Output | Notes |
|--------|-------|-----------------|-------|
| renderMarkdown | `# Hello` | `{ success: true, html: "<h1>Hello</h1>" }` | Basic |
| renderMarkdown | `null` | `{ success: true, html: "" }` | Null handling |
| renderMarkdown | `""` | `{ success: true, html: "" }` | Empty |
| renderMermaid | `graph TD; A-->B` | `{ success: true, svg: "<svg>..." }` | Valid |
| renderMermaid | `invalid` | `{ success: false, error: "..." }` | Invalid |
| renderMarkdownWithMermaid | MD + mermaid | HTML with SVG | Combined |
| renderMarkdownWithMermaid | MD only | HTML (no changes) | No mermaid |

### Browser Console Testing

```javascript
// Test renderMarkdown
console.log(JsonBridge.renderMarkdown('# Hello World'));

// Test renderMermaid
renderMermaid('graph TD; A-->B', 'dark').then(console.log);

// Test combined
JsonBridge.renderMarkdownWithMermaid('# Test\n```mermaid\ngraph TD; A-->B\n```', 'dark')
    .then(console.log);
```

## Definition of Done

- [ ] All acceptance criteria met
- [ ] All tasks completed
- [ ] renderMarkdown works from QML
- [ ] renderMermaid works from QML
- [ ] renderMarkdownWithMermaid works from QML
- [ ] Signals emitted correctly
- [ ] AsyncSerialiser integration verified
- [ ] Error handling complete
- [ ] Theme parameter works

## Dependencies

- **Depends on:** 10.1 (Rust Markdown), 10.2 (Mermaid.js)
- **Blocks:** 10.4 (Format Detection), 10.5 (Preview Pane), 10.6 (Syntax Highlighting)

## Estimate

2 points

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-28 | 1.0 | Story created from Epic 10.0 | Sarah (PO) |
