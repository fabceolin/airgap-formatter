# Story 8.1: Productionize XML Formatter

## Status: Approved

## Story

**As a** user formatting XML content,
**I want** reliable XML formatting with helpful error messages,
**so that** I can trust the tool to handle my XML correctly and debug issues when they occur.

## Acceptance Criteria

1. XML formatting produces correctly indented output for all valid XML inputs
2. XML minification removes all non-essential whitespace while preserving content
3. Parse errors include line and column position for debugging
4. All XML constructs are preserved: declarations, comments, CDATA, PIs, namespaces
5. Code follows DRY principles with shared event handling logic
6. Test coverage includes malformed XML and edge cases
7. WASM build succeeds with no new warnings

## Tasks / Subtasks

- [ ] Task 1: Extract shared event handling (AC: 5)
  - [ ] Create `write_event_owned()` helper function for event cloning
  - [ ] Refactor `format_xml()` to use shared helper
  - [ ] Refactor `minify_xml()` to use shared helper
  - [ ] Verify both functions produce identical output to before refactor

- [ ] Task 2: Add error position tracking (AC: 3)
  - [ ] Track line/column during parsing using `reader.buffer_position()`
  - [ ] Update `FormatError::new()` calls to include actual positions
  - [ ] Add test for error position accuracy

- [ ] Task 3: Expand test coverage (AC: 6)
  - [ ] Add malformed XML tests:
    - [ ] Unclosed tag
    - [ ] Mismatched tags
    - [ ] Invalid attribute syntax
    - [ ] Invalid entity reference
  - [ ] Add edge case tests:
    - [ ] Very deeply nested XML (100+ levels)
    - [ ] Large attribute values (>1KB)
    - [ ] Multiple namespace declarations
    - [ ] XML with BOM
    - [ ] Whitespace-only text nodes
  - [ ] Add roundtrip property test (format → minify → format = format)

- [ ] Task 4: Update module documentation (AC: 1, 2)
  - [ ] Update module doc comment from "Spike Investigation" to production description
  - [ ] Document public API with examples
  - [ ] Document known limitations (mixed content whitespace handling)

- [ ] Task 5: Verify WASM build (AC: 7)
  - [ ] Run `wasm-pack build --target web --release`
  - [ ] Confirm no new compiler warnings
  - [ ] Verify WASM exports work correctly

## Dev Notes

### Relevant Source Tree

```
src/
├── xml_formatter.rs    # TARGET FILE - refactor and harden
├── formatter.rs        # REFERENCE - JSON formatter pattern (uses serde_json error positions)
├── types.rs            # FormatError struct (line, column fields)
└── lib.rs              # WASM exports (js_format_xml, js_minify_xml)
```

### Current State (from Spike 7.0)

The PoC in `xml_formatter.rs` works but has:
- **Code duplication**: `format_xml()` and `minify_xml()` repeat event handling (lines 43-116 and 136-189)
- **No error positions**: All errors use `FormatError::new("...", 0, 0)` - no line/column
- **Basic tests only**: 9 tests covering happy path, need malformed XML coverage

### Key Patterns to Follow

**Error Handling (from formatter.rs:13-15):**
```rust
// JSON uses serde_json's error positions
let value: Value = serde_json::from_str(input).map_err(|e| {
    FormatError::new(e.to_string(), e.line(), e.column())
})?;
```

**For XML, use quick_xml's buffer_position():**
```rust
// Get byte offset, convert to line/column
let pos = reader.buffer_position();
// Note: quick-xml gives byte offset, not line/column
// You'll need to compute line/column from input string
```

### Line/Column Calculation Helper

```rust
fn position_to_line_column(input: &str, byte_offset: usize) -> (usize, usize) {
    let prefix = &input[..byte_offset.min(input.len())];
    let line = prefix.matches('\n').count() + 1;
    let column = prefix.rfind('\n').map(|i| byte_offset - i).unwrap_or(byte_offset + 1);
    (line, column)
}
```

### Shared Event Handling Pattern

Extract common logic into a helper:
```rust
fn write_event_to<W: std::io::Write>(
    writer: &mut Writer<W>,
    event: Event<'_>,
) -> Result<(), FormatError> {
    match event {
        Event::Start(e) => { /* clone and write */ }
        Event::End(e) => { /* clone and write */ }
        // ... etc
    }
}
```

### Known Limitations to Document

1. **Mixed content whitespace**: Text nodes have leading/trailing whitespace trimmed
2. **Attribute ordering**: Preserved from source, not sorted
3. **No DTD validation**: Parser accepts well-formed XML only

### Dependencies

- `quick-xml = "0.37"` (already in Cargo.toml from spike)

## Testing

### Test Location
- File: `src/xml_formatter.rs` (inline `#[cfg(test)] mod tests`)
- Pattern: Follow existing test structure in the file

### Test Standards
- Use `#[test]` attribute for unit tests
- Test both success and error cases
- Use descriptive test names: `test_<function>_<scenario>`
- Assert specific error messages for error cases

### Required Test Cases

| Category | Test | Expected |
|----------|------|----------|
| Malformed | Unclosed tag `<root>` | Error with position |
| Malformed | Mismatched `<a></b>` | Error with position |
| Malformed | Invalid attr `<a b>` | Error with position |
| Edge | Deep nesting (100 levels) | Success |
| Edge | Large attribute (1KB) | Success |
| Edge | Multiple namespaces | Preserved |
| Edge | BOM prefix | Handle gracefully |
| Property | format→minify→format | Idempotent |

### Running Tests
```bash
# Run XML formatter tests only
cargo test xml_formatter

# Run all tests
cargo test

# Run with output
cargo test xml_formatter -- --nocapture
```

## Definition of Done

- [ ] All acceptance criteria met
- [ ] All tasks completed
- [ ] All tests passing (existing + new)
- [ ] WASM build succeeds
- [ ] No new compiler warnings
- [ ] Code reviewed and follows project patterns

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-26 | 1.0 | Story created from Epic 8.0 | Sarah (PO) |
