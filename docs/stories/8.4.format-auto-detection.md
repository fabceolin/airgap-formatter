# Story 8.4: Format Auto-Detection

## Status: Approved

## Story

**As a** user pasting content into the formatter,
**I want** the application to automatically detect whether it's JSON or XML,
**so that** I don't have to manually select the format before formatting.

## Acceptance Criteria

1. Format is auto-detected when content is pasted into input pane
2. Format is auto-detected when Format button is clicked
3. Detection logic: `<` prefix = XML, `{` or `[` prefix = JSON
4. Unknown format handled gracefully (default to JSON or show message)
5. `formatDetected` signal emitted with detected format ("json", "xml", "unknown")
6. Detection works for content with leading whitespace
7. Detection is fast (< 1ms for any input size)

## Tasks / Subtasks

- [ ] Task 1: Add detection method to JsonBridge (AC: 3, 6, 7)
  - [ ] Add `Q_INVOKABLE QString detectFormat(const QString &input)`
  - [ ] Implement detection: trim whitespace, check first character
  - [ ] Return "json", "xml", or "unknown"
  - [ ] Handle empty input (return "unknown")

- [ ] Task 2: Add formatDetected signal (AC: 5)
  - [ ] Add signal `void formatDetected(const QString &format)` to jsonbridge.h
  - [ ] Emit signal from detection method

- [ ] Task 3: Integrate detection in Main.qml (AC: 1, 2)
  - [ ] Add property `property string detectedFormat: "json"`
  - [ ] Call `JsonBridge.detectFormat()` on input text change
  - [ ] Call `JsonBridge.detectFormat()` before format/minify operations
  - [ ] Connect to `formatDetected` signal to update `detectedFormat`

- [ ] Task 4: Handle unknown format (AC: 4)
  - [ ] When format is "unknown", default to JSON (current behavior)
  - [ ] Optionally: show subtle indicator in status bar
  - [ ] Document this behavior

- [ ] Task 5: Update format/minify routing (AC: 2)
  - [ ] Modify toolbar Format button handler to use detected format
  - [ ] If detectedFormat == "xml", call `formatXml()`
  - [ ] If detectedFormat == "json" or "unknown", call `formatJson()`
  - [ ] Same logic for Minify button

- [ ] Task 6: Add tests (AC: 1-7)
  - [ ] Test: `{"a":1}` → "json"
  - [ ] Test: `[1,2,3]` → "json"
  - [ ] Test: `<root/>` → "xml"
  - [ ] Test: `<?xml version="1.0"?>` → "xml"
  - [ ] Test: `  \n  <root/>` (whitespace prefix) → "xml"
  - [ ] Test: `  \n  {"a":1}` (whitespace prefix) → "json"
  - [ ] Test: `hello` → "unknown"
  - [ ] Test: `` (empty) → "unknown"

## Dev Notes

### Relevant Source Tree

```
qt/
├── jsonbridge.h        # Add detectFormat() method and signal
├── jsonbridge.cpp      # Implement detection logic
└── qml/
    ├── Main.qml        # Add detectedFormat property, connect signal
    └── Toolbar.qml     # Route format/minify to correct method
```

### Detection Algorithm

```cpp
QString JsonBridge::detectFormat(const QString &input)
{
    QString trimmed = input.trimmed();

    if (trimmed.isEmpty()) {
        return QStringLiteral("unknown");
    }

    QChar first = trimmed.at(0);

    if (first == '<') {
        return QStringLiteral("xml");
    }

    if (first == '{' || first == '[') {
        return QStringLiteral("json");
    }

    return QStringLiteral("unknown");
}
```

### Main.qml Integration Pattern

```qml
ApplicationWindow {
    // Add format tracking
    property string detectedFormat: "json"

    Connections {
        target: JsonBridge

        function onFormatDetected(format) {
            detectedFormat = format;
        }
    }

    // Detect on input change
    Connections {
        target: inputPane
        function onTextChanged() {
            if (inputPane.text.length > 0) {
                JsonBridge.detectFormat(inputPane.text);
            }
        }
    }
}
```

### Toolbar Format Button Handler Update

```qml
// In Toolbar.qml or Main.qml
function handleFormat() {
    var format = window.detectedFormat;
    var indent = toolbar.selectedIndent;

    if (format === "xml") {
        JsonBridge.formatXml(inputPane.text, indent);
    } else {
        // Default to JSON for "json" or "unknown"
        JsonBridge.formatJson(inputPane.text, indent);
    }
}
```

### Edge Cases

| Input | Expected Format | Notes |
|-------|-----------------|-------|
| `{"a":1}` | json | Standard JSON object |
| `[1,2,3]` | json | JSON array |
| `<root/>` | xml | Self-closing XML |
| `<?xml...` | xml | XML declaration |
| `<!DOCTYPE html>` | xml | HTML doctype (treated as XML) |
| ` \n\t{"a":1}` | json | Whitespace trimmed |
| `null` | unknown | JSON primitive but ambiguous |
| `123` | unknown | Could be anything |
| `` | unknown | Empty input |

## Testing

### Test Location
- C++ tests: `qt/tests/tst_format_detection.cpp` (new file)
- QML integration: Manual testing

### Test Cases

| Input | Expected | Notes |
|-------|----------|-------|
| `{"key": "value"}` | "json" | Object |
| `[1, 2, 3]` | "json" | Array |
| `<root><child/></root>` | "xml" | Nested XML |
| `<?xml version="1.0"?><r/>` | "xml" | With declaration |
| `   {"key": 1}` | "json" | Leading whitespace |
| `\n\n<root/>` | "xml" | Leading newlines |
| `hello world` | "unknown" | Plain text |
| `` | "unknown" | Empty |
| `   ` | "unknown" | Whitespace only |

### Running Tests
```bash
# Build and run detection tests
cd qt/build
cmake .. && make
./tests/tst_format_detection
```

## Definition of Done

- [ ] All acceptance criteria met
- [ ] All tasks completed
- [ ] Detection works for JSON and XML
- [ ] Unknown format defaults to JSON
- [ ] Signal properly emitted
- [ ] QML integration working

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-26 | 1.0 | Story created from Epic 8.0 | Sarah (PO) |
